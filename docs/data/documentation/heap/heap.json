{"schemaVersion":{"major":0,"patch":0,"minor":3},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Heap\/documentation\/Heap\/Heap"},"hierarchy":{"paths":[["doc:\/\/Heap\/documentation\/Heap"]]},"relationshipsSections":[{"kind":"relationships","title":"Inherited By","type":"inheritedBy","identifiers":["doc:\/\/Heap\/documentation\/Heap\/MaxHeap","doc:\/\/Heap\/documentation\/Heap\/MinHeap"]},{"type":"conformsTo","title":"Conforms To","identifiers":["doc:\/\/Heap\/22IteratableListProtocol0A1PP","doc:\/\/Heap\/s8CopyableP","doc:\/\/Heap\/s23CustomStringConvertibleP","doc:\/\/Heap\/St","doc:\/\/Heap\/ST"],"kind":"relationships"}],"topicSections":[{"identifiers":["doc:\/\/Heap\/documentation\/Heap\/Heap\/init(array:sort:)","doc:\/\/Heap\/documentation\/Heap\/Heap\/init(sort:)"],"title":"Initializers","generated":true,"anchor":"Initializers"},{"title":"Instance Properties","identifiers":["doc:\/\/Heap\/documentation\/Heap\/Heap\/isEmpty","doc:\/\/Heap\/documentation\/Heap\/Heap\/size"],"generated":true,"anchor":"Instance-Properties"},{"generated":true,"title":"Instance Methods","anchor":"Instance-Methods","identifiers":["doc:\/\/Heap\/documentation\/Heap\/Heap\/next()","doc:\/\/Heap\/documentation\/Heap\/Heap\/peek()","doc:\/\/Heap\/documentation\/Heap\/Heap\/pop()","doc:\/\/Heap\/documentation\/Heap\/Heap\/popPush(_:)","doc:\/\/Heap\/documentation\/Heap\/Heap\/push(_:)","doc:\/\/Heap\/documentation\/Heap\/Heap\/pushPop(_:)","doc:\/\/Heap\/documentation\/Heap\/Heap\/removeAll()"]},{"anchor":"Default-Implementations","generated":true,"identifiers":["doc:\/\/Heap\/documentation\/Heap\/Heap\/CustomStringConvertible-Implementations","doc:\/\/Heap\/documentation\/Heap\/Heap\/Sequence-Implementations"],"title":"Default Implementations"}],"metadata":{"modules":[{"name":"Heap"}],"fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Heap"}],"title":"Heap","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Heap"}],"symbolKind":"class","externalID":"s:4HeapAAC","roleHeading":"Class"},"kind":"symbol","abstract":[{"type":"text","text":"A binary heap is a heap data structure that takes the form of a binary tree."},{"type":"text","text":" "},{"type":"text","text":"A binary heap has two constraints:"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Heap"},{"kind":"text","text":"<"},{"text":"T","kind":"genericParameter"},{"text":"> ","kind":"text"},{"text":"where","kind":"keyword"},{"kind":"text","text":" "},{"text":"T","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"text":"Comparable","kind":"typeIdentifier","preciseIdentifier":"s:SL"}]}]},{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"completeness: it is a complete binary tree, with slots filled at the leaf nodes from left to right."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"the shape constraint: the value stored in each node is either greater than or equal to (for a max heap)"},{"text":" ","type":"text"},{"text":"or less than or equal to (for a min heap) the values in the nodeâ€™s children. This is true","type":"text"},{"type":"text","text":" "},{"text":"per level, but sibling nodes have no such sequence with regard to each other.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two kinds of heaps: min-heaps and max-heaps."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"A  binary  tree  maintains O(log n) insertion and deletion times for a","type":"text"},{"type":"text","text":" "},{"text":"heap of size n.","type":"text"}]}],"name":"Complexity","type":"aside","style":"note"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/heap\/heap"]}],"sections":[],"references":{"doc://Heap/documentation/Heap/MaxHeap":{"abstract":[{"type":"text","text":"Convenience initializers for a Max Heap"}],"kind":"symbol","title":"MaxHeap","url":"\/documentation\/heap\/maxheap","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxHeap","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"MaxHeap"}],"role":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/MaxHeap"},"doc://Heap/documentation/Heap/Heap/peek()":{"abstract":[{"text":"Non-destructively returns the value at the top of the Heap.","type":"text"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/peek()","title":"peek()","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"peek","kind":"identifier"},{"text":"() -> ","kind":"text"},{"text":"T","kind":"typeIdentifier"},{"text":"?","kind":"text"}],"role":"symbol","url":"\/documentation\/heap\/heap\/peek()"},"doc://Heap/documentation/Heap/Heap/push(_:)":{"kind":"symbol","type":"topic","abstract":[{"text":"Insert a new value into the Heap.","type":"text"},{"text":" ","type":"text"},{"text":"The value is added as a HeapNode at the end of the Heap, then a bubble-up occurs.","type":"text"}],"title":"push(_:)","url":"\/documentation\/heap\/heap\/push(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"push","kind":"identifier"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":")"}],"role":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/push(_:)"},"doc://Heap/documentation/Heap/Heap":{"url":"\/documentation\/heap\/heap","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Heap","kind":"identifier"}],"navigatorTitle":[{"text":"Heap","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A binary heap is a heap data structure that takes the form of a binary tree."},{"type":"text","text":" "},{"text":"A binary heap has two constraints:","type":"text"}],"kind":"symbol","title":"Heap","role":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap"},"doc://Heap/documentation/Heap/Heap/CustomStringConvertible-Implementations":{"type":"topic","abstract":[],"url":"\/documentation\/heap\/heap\/customstringconvertible-implementations","kind":"article","title":"CustomStringConvertible Implementations","role":"collectionGroup","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/CustomStringConvertible-Implementations"},"doc://Heap/documentation/Heap/Heap/popPush(_:)":{"url":"\/documentation\/heap\/heap\/poppush(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"popPush","kind":"identifier"},{"kind":"text","text":"("},{"text":"T","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"T","kind":"typeIdentifier"},{"text":"?","kind":"text"}],"type":"topic","abstract":[{"text":"Extract then insert in same operation (aka replace root element).","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Heap will heapify, if required, but the prior top element is returned."},{"text":" ","type":"text"},{"text":"This is more effecient than a consecutive pop, then push, which would both","type":"text"},{"type":"text","text":" "},{"text":"require an O(n) operation (a bubble-down then a bubble-up).","type":"text"}],"kind":"symbol","title":"popPush(_:)","role":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/popPush(_:)"},"doc://Heap/documentation/Heap/Heap/init(sort:)":{"abstract":[{"text":"Creates an empty heap.","type":"text"},{"type":"text","text":" "},{"text":"The sort function determines whether this is a min-heap or max-heap.","type":"text"}],"role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"kind":"text","text":"("},{"kind":"externalParam","text":"sort"},{"kind":"text","text":": ("},{"text":"T","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"T"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"},{"text":")","kind":"text"}],"type":"topic","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/init(sort:)","url":"\/documentation\/heap\/heap\/init(sort:)","kind":"symbol","title":"init(sort:)"},"doc://Heap/documentation/Heap/Heap/isEmpty":{"url":"\/documentation\/heap\/heap\/isempty","fragments":[{"kind":"keyword","text":"var"},{"text":" ","kind":"text"},{"kind":"identifier","text":"isEmpty"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"type":"topic","abstract":[{"type":"text","text":"Check if the Heap contains any elements"}],"kind":"symbol","title":"isEmpty","role":"symbol","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/isEmpty"},"doc://Heap/documentation/Heap/Heap/size":{"identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/size","type":"topic","kind":"symbol","url":"\/documentation\/heap\/heap\/size","role":"symbol","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"size"},{"kind":"text","text":": "},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"The number of elements in the Heap"}],"title":"size"},"doc://Heap/documentation/Heap/Heap/Sequence-Implementations":{"type":"topic","kind":"article","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/Sequence-Implementations","role":"collectionGroup","abstract":[],"title":"Sequence Implementations","url":"\/documentation\/heap\/heap\/sequence-implementations"},"doc://Heap/documentation/Heap/Heap/init(array:sort:)":{"identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/init(array:sort:)","type":"topic","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"T"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"url":"\/documentation\/heap\/heap\/init(array:sort:)","role":"symbol","abstract":[{"text":"Convenience initializers for loading a Heap from an array.","type":"text"}],"kind":"symbol","title":"init(array:sort:)","fragments":[{"kind":"keyword","text":"convenience"},{"kind":"text","text":" "},{"text":"init","kind":"identifier"},{"text":"(","kind":"text"},{"text":"array","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sa","text":"Array"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier"},{"kind":"text","text":">, "},{"text":"sort","kind":"externalParam"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"T"},{"text":", ","kind":"text"},{"kind":"typeIdentifier","text":"T"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"},{"text":")","kind":"text"}]},"doc://Heap/St":{"title":"Swift.IteratorProtocol","type":"unresolvable","identifier":"doc:\/\/Heap\/St"},"doc://Heap/s23CustomStringConvertibleP":{"title":"Swift.CustomStringConvertible","type":"unresolvable","identifier":"doc:\/\/Heap\/s23CustomStringConvertibleP"},"doc://Heap/documentation/Heap":{"title":"Heap","identifier":"doc:\/\/Heap\/documentation\/Heap","abstract":[],"type":"topic","kind":"symbol","role":"collection","url":"\/documentation\/heap"},"doc://Heap/documentation/Heap/Heap/pushPop(_:)":{"url":"\/documentation\/heap\/heap\/pushpop(_:)","title":"pushPop(_:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"pushPop","kind":"identifier"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"T"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"T"},{"text":"?","kind":"text"}],"identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/pushPop(_:)","type":"topic","abstract":[{"type":"text","text":"Insert at the root and then extract (after heapify if required) in same operation."},{"text":" ","type":"text"},{"type":"text","text":"This is more effecient than a consecutive push, then pop, which would both"},{"text":" ","type":"text"},{"type":"text","text":"require an O(n) operation (a bubble-up then a bubble-down)."}],"role":"symbol"},"doc://Heap/documentation/Heap/Heap/removeAll()":{"url":"\/documentation\/heap\/heap\/removeall()","type":"topic","role":"symbol","abstract":[{"type":"text","text":"Removes the elements of the Heap."}],"kind":"symbol","title":"removeAll()","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/removeAll()","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"removeAll","kind":"identifier"},{"kind":"text","text":"()"}]},"doc://Heap/documentation/Heap/Heap/next()":{"title":"next()","type":"topic","url":"\/documentation\/heap\/heap\/next()","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"next"},{"text":"() -> ","kind":"text"},{"kind":"typeIdentifier","text":"T"},{"text":"?","kind":"text"}],"identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/next()","abstract":[{"type":"text","text":"For conformance to Sequence protocol."},{"type":"text","text":" "},{"text":"Synonym for pop().","type":"text"}]},"doc://Heap/documentation/Heap/Heap/pop()":{"url":"\/documentation\/heap\/heap\/pop()","type":"topic","role":"symbol","abstract":[{"text":"Remove the top of the heap and return its value. The top is replaced with","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the last inserted element, then we call bubbleDown to heapify."}],"kind":"symbol","title":"pop()","identifier":"doc:\/\/Heap\/documentation\/Heap\/Heap\/pop()","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"pop","kind":"identifier"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":"?"}]},"doc://Heap/s8CopyableP":{"type":"unresolvable","title":"Swift.Copyable","identifier":"doc:\/\/Heap\/s8CopyableP"},"doc://Heap/documentation/Heap/MinHeap":{"url":"\/documentation\/heap\/minheap","type":"topic","role":"symbol","abstract":[{"type":"text","text":"Convenience initializers for a Min Heap"}],"kind":"symbol","title":"MinHeap","identifier":"doc:\/\/Heap\/documentation\/Heap\/MinHeap","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"MinHeap","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"MinHeap"}]},"doc://Heap/22IteratableListProtocol0A1PP":{"title":"IteratableListProtocol.IteratableP","identifier":"doc:\/\/Heap\/22IteratableListProtocol0A1PP","type":"unresolvable"},"doc://Heap/ST":{"title":"Swift.Sequence","identifier":"doc:\/\/Heap\/ST","type":"unresolvable"}}}